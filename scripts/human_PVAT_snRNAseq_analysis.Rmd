---
title: "SnRNA-sequencing analysis of human perivascular adipose tissue (PVAT)"
author: "Hannah Bazin"
date: "r doc_date()"
output: BiocStyle::html_document:
      toc: yes
      toc_depth: 3
      toc_float: yes
      code_folding: "hide" 
---

In this vignette, I analyse three datasets of single-nucleus RNA sequencing of human perivascular adipose tissue (PVAT). There are 12’657, 6’084 and 6’456 cells in three samples respectively that were sequenced on the Illumina NovaSeq 6000. The raw data can be found on the Gene Expression Omnibus website, [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164528). I am building on code from Holly A. R. Giles.

# Set up

```{r}

# Set random seed for reproducibility
set.seed(1996)

```

## Load libraries

```{r}

library(GEOquery)
library(Seurat)
library(dplyr)
library(patchwork)
library(ggplot2)
library(ggpubr)
library(tidyverse)

```

## Set working directory

The working directory can be set by running the following command in the terminal: `setwd("/Users/hannahbazin/Desktop/Cambridge/Academics/Han_Lab/MPhil/mphil-project")`

## Load data

The data stems from single-nucleus RNA sequencing experiments of human perivascular adipose tissue from three different healthy donors, sequenced with Illumina NovaSeq 6000. The raw data can be found [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164528). It was first published by Angueira et al. on 12 April 2021 in Nature Metabolism in the paper titled "Defining the lineage of thermogenic perivascular adipose tissue" ([link](https://pubmed.ncbi.nlm.nih.gov/33846639/)).

We read in the data using the `Read10X()` function which takes in three files (barcodes.tsv, genes.tsv, and matrix.mtx) and returns a UMI sparse count matrix representing the gene expression data. This function can be used because the data was generated using CellRanger.

```{r}

# Read in the 10X data
human1_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068996_hPVAT1/")
human2_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068997_hPVAT2/")
human3_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068998_hPVAT3/")

```

We create Seurat objects from the raw data using `CreateSeuratObject()`. A Seurat object contains both the data (e.g. counts matrix) and the analysis (e.g. clustering results). The parameters `min.cell` and `min.features` allow for initial filtering: we remove genes expressed in less than three cells (sparse expression), as well as cells with fewer than 200 detected genes.

```{r}

# Create Seurat objects for each sample
human1 <- CreateSeuratObject(counts = human1_data, project = "GSE164528", min.cells = 3, min.features = 200)
human2 <- CreateSeuratObject(counts = human2_data, project = "GSE164528", min.cells = 3, min.features = 200)
human3 <- CreateSeuratObject(counts = human3_data, project = "GSE164528", min.cells = 3, min.features = 200)

# See number of cells in each sample
ncol(human1)
ncol(human2)
ncol(human3)

```

# Pre-processing workflow

## Visualise QC metrics and select cells

### Add mitochondrial reads

We add the percentage of mitochondrial genes to the metadata for all three samples. This is an important Quality Control metric. In single nucleus RNA sequencing data, as opposed to those from single cell RNA sequencing, we expect close to no low mitochondrial gene expression. We need to filter out the samples with high mitochondrial gene expression, because this might indicate that the mitochondria attached to the nucleus during isolation.

The `[[` operator can add columns to object metadata. First, we store the mitochondrial QC stat here. The `^` character ensures it matches only the start of a string.

```{r}

# Add percentage of mitochondrial genes
human1[["percent.mt"]] <- PercentageFeatureSet(human1, pattern = "^MT-")
human2[["percent.mt"]] <- PercentageFeatureSet(human2, pattern = "^MT-")
human3[["percent.mt"]] <- PercentageFeatureSet(human3, pattern = "^MT-")

```

### Determine cut-off

We visualise Quality Control metrics for each of the samples and determine the cut-off for filtering the cells based on these plots.

```{r}

# Show QC metrics for the first 5 cells of each sample
head(human1@meta.data, 5)
head(human2@meta.data, 5)
head(human3@meta.data, 5)

```

```{r fig.height=7, fig.width=13}

# Plot QC metrics for each sample
VlnPlot(human1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(human2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(human3, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

```

```{r fig.height=7, fig.width=11}

# Plot FeatureScatter plots for each sample
plot1 <- FeatureScatter(human1, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(human2, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(human3, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human3, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

```

### Filter cells

The filtering metrics are:

-   `nFeature_RNA`: number of non-zero expressed genes in one cell, thus indicates the diversity of gene expression within a cell. Low values suggest low-quality cells or empty droplets; high values may indicate doublets or multiplets.
-   `nCount_RNA`: total RNA count per cell, reflecting transcriptional activity. Low values suggest low-quality cells; high values may indicate doublets or multiplets.
-   `percent.mt`: percentage of mitochondrial genes in one cell. High values indicate bad quality of cells.

From the violin plots, we identify the filtering thresholds and select cells as follows:

-   Filter cells that have unique feature counts over 6'000 or below 1'000.
-   Filter cells that have RNA counts over 40'000 and below 500.
-   Filter cells that have \>1% mitochondrial counts.

We use the same cut-off values in all three samples for consistency.

```{r}

# Filter cells for QC
human1_filtered <- subset(human1, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)
human2_filtered <- subset(human2, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)
human3_filtered <- subset(human3, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)

# See number of cells in each sample after QC
ncol(human1_filtered)
ncol(human2_filtered)
ncol(human3_filtered)

```

# Normalise data and find variable features

We normalise the data using a global-scaling method called "LogNormalize". This process normalises the feature expression levels for each cell by dividing by the total expression, multiplies this by a scale factor (10'000 by default), and applies a log transformation to the result. Normalised values are stored in `human1[["RNA"]]@data`.

We also identify features that have high cell-to-cell variation, these are likely to have the most biological significance. The function returns 2'000 features per dataset by default.

```{r}

# Add metadata to account for sample origin
human1_filtered$sampleType <- "human1"
human2_filtered$sampleType <- "human2"
human3_filtered$sampleType <- "human3"

lib_list_filtered <- list(human1_filtered, human2_filtered, human3_filtered)

# Normalise data and find variable features
lib_list_filtered <- lapply(X = lib_list_filtered, FUN = function(seurat_object) {
  
  seurat_object <- NormalizeData(seurat_object)
  seurat_object <- FindVariableFeatures(seurat_object, selection.method = "vst", nfeatures = 2000)
  
})

# Select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = lib_list_filtered)

```

We visualise the variable features.

```{r fig.height=5, fig.width=11}

lapply(1:length(lib_list_filtered), function(i) {
 
   x <- lib_list_filtered[[i]]
  
  # Identify the 10 most highly variable genes
  top10 <- head(VariableFeatures(x), 10)

  # Plot variable features with and without labels
  plot1 <- VariableFeaturePlot(x)
  plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
  plot1 + plot2 + plot_annotation(title = names(lib_list_filtered[i]))
  
})

```

# Integrate data

Integration of data from the three different donors is an important step in this snRNA-seq workflow. This ensures that cells cluster based on biological state and not on sample origin. Details can be found in [this vignette](https://satijalab.org/seurat/archive/v4.3/integration_introduction). I am building on code from this vignette and from Holly A. R. Giles.

## Find integration anchors

```{r}

# Find integration anchors
  # This is a time-consuming step, save the object

if (file.exists("data/analysis/anchors.RData")) {
  
  print("file exists")
  
  load(file = "data/analysis/anchors.RData")
  
} else {
  
  print("file does not exist")
  
  anchors <- FindIntegrationAnchors(object.list = lib_list_filtered, anchor.features = features)
  
  save(anchors, file = "data/analysis/anchors.RData")

}
```

## Perform integration

```{r}

# Use anchors to generate an integrated data assay
  # This is a time-consuming step, save the object
  # Delete objects before running if new changes to code

if (file.exists("data/analysis/libs_combined.RData")) {
  
  load(file = "data/analysis/libs_combined.RData")
  
} else {
  
  libs_combined <- IntegrateData(anchorset = anchors)
  
  save(libs_combined, file = "data/analysis/libs_combined.RData")
  
}

# Check dimensions of libs_combined
libs_combined

```

# Scale data

We scale the data so that highly expressed genes do not dominate in the downstream analyses. The `ScaleData()` function ensures the mean expression across cells becomes 0, and the variance becomes 1. We also regress out unwanted sources of variation such as mitochondrial reads.

```{r}

# Ensure default assay is integrated data
DefaultAssay(libs_combined) <- "integrated"

# Scale data and regress out unwanted variation due to mitochondrial reads
libs_combined <- ScaleData(libs_combined, vars.to.regress = 'percent.mt')

```

# Linear dimensionality reduction

We perform PCA on the scaled data with the variable features as input.

## Run PCA

```{r}

# By default, only the previously determined variable features are used as input.

libs_combined <- RunPCA(libs_combined, npcs = 30)

```

## Determine dimensionality of the dataset

We plot an elbow plot to determine the dimensionality of the dataset. From this plot we can see that the line starts to flatten significantly around PC 10. Therefore in the downstream analysis we keep 10 dimensions of the dataset.

```{r cache = FALSE}

elbow_plot <- ElbowPlot(libs_combined, ndims = 25)

# Save elbow plot as PDF
if (!dir.exists("results/humanPVATsn")) dir.create("results/humanPVATsn")

pdf("results/humanPVATsn/elbow_plot.pdf", width = 8, height = 6)
print(elbow_plot)
invisible(dev.off())

# Display elbow plot
elbow_plot

```

## Visualise PCA results

```{r}

DimPlot(libs_combined, reduction = "pca", 
              group.by = "sampleType")

FeaturePlot(object = libs_combined, reduction = "pca", features = "percent.mt")

```

## Run and visualise UMAP

Note: human1 is a healthy weight, human2 is overweight, and human3 is obese.

```{r message = FALSE, cache = FALSE}
libs_combined <- RunUMAP(libs_combined, reduction = "pca", dims = 1:20)

# Plot UMAP by sample type
p1 <- DimPlot(libs_combined,
              reduction = "umap",
              group.by = "sampleType") +
  ggtitle("UMAP coloured by sample origin")

p2 <- DimPlot(libs_combined,
              reduction = "umap",
              split.by = "sampleType",
              group.by = "sampleType",
              ncol = 3) +
  ggtitle("UMAP of all samples")

# Save plots as PDFs
if (!dir.exists("results/humanPVATsn")) dir.create("results/humanPVATsn")

pdf("results/humanPVATsn/UMAP_by_sample_origin.pdf", width = 8, height = 6)
print(p1)
invisible(dev.off())

pdf("results/humanPVATsn/UMAP_all_samples.pdf", width = 12, height = 6)
print(p2)
invisible(dev.off())

# Display plots
p1
p2

```

The percentage of mitochondrial gene counts seems well distributed across the clusters, therefore we can continue with the downstream analysis.

```{r}

mito_plot <- FeaturePlot(object = libs_combined, reduction = "umap", features = "percent.mt")

pdf("results/humanPVATsn/UMAP_mt_percent.pdf", width = 12, height = 6)
print(mito_plot)
invisible(dev.off())

# Display plots
mito_plot

```

# Find neighbors and clusters

I adapted the resolution to create an approximate number of clusters I am expecting based on the paper of reference (Angueira et al., 2021).

```{r}

libs_combined <- FindNeighbors(libs_combined, reduction = "pca", dims = 1:10)

libs_combined <- FindClusters(libs_combined, resolution = 0.35, random.seed = 1996)

# Look at cluster IDs of the first 5 cells
head(Idents(libs_combined), 5)

```

## Visualise clusters on UMAP

We visualise the clusters based on cluster number.

```{r}

# Plot UMAP with cluster numbers
umap_with_numbers <- DimPlot(libs_combined,
                            reduction = "umap",
                            label = TRUE) +
  ggtitle("UMAP with Cluster Numbers")

# Save plot
pdf("results/humanPVATsn/UMAP_with_cluster_numbers.pdf", width = 12, height = 6)
print(umap_with_numbers)
invisible(dev.off())

# Show plot
umap_with_numbers

```

```{r}
# Plot UMAP with cluster numbers, split by sample
umap_with_numbers_by_sample <- DimPlot(libs_combined,
                            reduction = "umap",
                            split.by = "sampleType",
                            label = TRUE) +
  ggtitle("UMAP with Cluster Numbers Split by Sample")

# Save plot
pdf("results/humanPVATsn/UMAP_with_cluster_numbers_by_sample.pdf", width = 12, height = 6)
print(umap_with_numbers_by_sample)
invisible(dev.off())

# Show plot
umap_with_numbers_by_sample
```



# Find markers

Before differential gene expression analysis, we return to the RNA assay instead of the integrated one. The function `FindAllMarkers()` finds markers (differentially expressed genes) for each of the clusters in a dataset. By default, it uses a Wilcoxon Rank Sum test to identify differentially expressed genes between two groups. The parameters are set as follows:

- only.pos = T only returns positive markers
- min.pct = 0.3 only tests genes detected in 30% of either of the two populations being compared. This speeds up the function and allows us to focus on more biologically relevant genes. 
- logfc.threshold = 0.3 limits testing to genes that show at least 0.3-fold difference (log-scale) between the two groups (removes weaker signals)

```{r}

# Return to RNA assay as default for DGEA
DefaultAssay(libs_combined) <- "RNA"

# Find markers
  # This is a time-consuming step, save the object
if(file.exists("data/analysis/cluster_markers.RData")){
  
  load(file = "data/analysis/cluster_markers.RData")

  }else{
    
    markers <- FindAllMarkers(libs_combined, only.pos = T, min.pct = 0.3, logfc.threshold = 0.3)
    
    save(markers, file = "data/analysis/cluster_markers.RData")

  }

# Show the top ten markers in each cluster
top8 <- markers %>% group_by(cluster) %>% slice_max(n = 8, order_by = avg_log2FC)

top10 <- markers %>% group_by(cluster) %>% slice_max(n = 10, order_by = avg_log2FC)

top20 <- markers %>% group_by(cluster) %>% slice_max(n = 20, order_by = avg_log2FC)

top10

```

We generate a table of cluster markers for reference.

```{r warning = FALSE}

# Determine number of clusters
num_clusters <- max(as.numeric(as.character(libs_combined@meta.data$seurat_clusters)))

lapply(0:num_clusters, function(i) {
  
  # Select relevant information
  tab <- filter(markers, cluster == i) %>% 
    select(gene, p_val, p_val_adj, avg_log2FC, cluster)
  
  # Export as csv for Excel
  write.csv(tab, file = paste0("results/humanPVATsn/markersCluster", i, ".csv"))
  
  # Print as datatable
  DT::datatable(tab)
  
})

```

## Plot markers

Plot the top 8 marker genes for each cluster.

```{r fig.height=20, fig.width=15}

# Ensure that RNA assay is used and not integrated assay
DefaultAssay(libs_combined) <- "RNA"

violinPlots <-
  lapply(0:num_clusters, function(i) {
    
    # Get a list of genes
    features_to_plot <- filter(top8, cluster == i)$gene
    
    # Get a list of violin plots, 8 per cluster
    violinList <- VlnPlot(libs_combined, features = features_to_plot)
    
    # Plot a set of 8 violin plots for each cluster
    violinList[[1]] + violinList[[2]] + violinList[[3]] + 
      violinList[[4]] + violinList[[5]] + violinList[[6]] + 
      violinList[[7]] + violinList[[8]] +
      # Add cluster number as title
      plot_annotation(title = paste("Cluster", i, sep = " "),
                      theme = theme(plot.title = element_text(size = 18, face = "bold")))

  })

violinPlots

```








**Session Info**

```{r}

sessionInfo()

```
