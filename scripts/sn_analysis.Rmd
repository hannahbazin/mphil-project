---
title: "SnRNA-sequencing analysis of human perivascular adipose tissue (PVAT)"
author: "Hannah Bazin"
date: "r doc_date()"
output: BiocStyle::html_document:
      toc: yes
      toc_depth: 3
      toc_float: yes
      code_folding: "hide" 
---

In this vignette, we are analysing a dataset of single-nucleus RNA sequencing data available on the Gene Expression Omnibus website. There are  single cells that were sequenced on the Illumina NovaSeq 6000. The raw data can be found [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164528).

# Set up

## Load libraries

```{r}
library(GEOquery)
library(Seurat)
library(dplyr)
library(patchwork)
library(ggplot2)
library(ggpubr)
library(tidyverse)
```

## Set working directory

The working directory can be set by running the following command in the terminal: `setwd("/Users/hannahbazin/Desktop/Cambridge/Academics/Han_Lab/MPhil/mphil-project")`

## Load data

The data stems from single-nucleus RNA sequencing experiments of human perivascular adipose tissue from three different healthy donors, sequenced with Illumina NovaSeq 6000. The raw data can be found [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164528). It was first published by Angueira et al. on 12 April 2021 in Nature Metabolism in the paper titled "Defining the lineage of thermogenic perivascular adipose tissue" ([link](https://pubmed.ncbi.nlm.nih.gov/33846639/)).

We read in the data using the `Read10X()` function which takes in three files (barcodes.tsv, genes.tsv, and matrix.mtx) and returns a UMI sparse count matrix representing the gene expression data. This function can be used because the data was generated using CellRanger.

```{r}
human1_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068996_hPVAT1/")
human2_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068997_hPVAT2/")
human3_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068998_hPVAT3/")
```

We create Seurat objects from the raw data using `CreateSeuratObject()`. A Seurat object contains both the data (e.g. counts matrix) and the analysis (e.g. clustering results). The parameters `min.cell` and `min.features` allow for initial filtering: we remove genes expressed in less than three cells (sparse expression), as well as cells with fewer than 200 detected genes.

```{r}
human1 <- CreateSeuratObject(counts = human1_data, project = "GSE164528", min.cells = 3, min.features = 200)
human2 <- CreateSeuratObject(counts = human2_data, project = "GSE164528", min.cells = 3, min.features = 200)
human3 <- CreateSeuratObject(counts = human3_data, project = "GSE164528", min.cells = 3, min.features = 200)

# See number of cells in each sample
ncol(human1)
ncol(human2)
ncol(human3)
```

# Pre-processing workflow

## Visualise QC metrics and select cells

### Add mitochondrial reads

We add the percentage of mitochondrial genes to the metadata for all three samples. This is an important Quality Control metric. In single nucleus RNA sequencing data, as opposed to those from single cell RNA sequencing, we expect close to no low mitochondrial gene expression. We need to filter out the samples with high mitochondrial gene expression, because this might indicate that the mitochondria attached to the nucleus during isolation.

The `[[` operator can add columns to object metadata. First, we store the mitochondrial QC stat here. The `^` character ensures it matches only the start of a string.


```{r}
human1[["percent.mt"]] <- PercentageFeatureSet(human1, pattern = "^MT-")
human2[["percent.mt"]] <- PercentageFeatureSet(human2, pattern = "^MT-")
human3[["percent.mt"]] <- PercentageFeatureSet(human3, pattern = "^MT-")
```

### Determine cut-off

We visualise Quality Control metrics for each of the samples and determine the cut-off for filtering the cells based on these plots.

```{r}
# Show QC metrics for the first 5 cells of each sample
head(human1@meta.data, 5)
head(human2@meta.data, 5)
head(human3@meta.data, 5)
```

```{r fig.height=7, fig.width=13}
VlnPlot(human1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(human2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(human3, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

```{r fig.height=7, fig.width=11}
plot1 <- FeatureScatter(human1, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(human2, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(human3, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human3, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

### Filter cells

The filtering metrics are:

-   `nFeature_RNA`: number of non-zero expressed genes in one cell, thus indicates the diversity of gene expression within a cell. Low values suggest low-quality cells or empty droplets; high values may indicate doublets or multiplets.
- `nCount_RNA`:  total RNA count per cell, reflecting transcriptional activity. Low values suggest low-quality cells; high values may indicate doublets or multiplets.
-   `percent.mt`: percentage of mitochondrial genes in one cell. High values indicate bad quality of cells.

From the violin plots, we identify the filtering thresholds and select cells as follows: - We filter cells that have unique feature counts over 6'000 or below 1'000. - We filter cells that have RNA counts over 40'000 and below 500. - We filter cells that have \>1% mitochondrial counts. We use the same cut-off values in all three samples for consistency.


```{r}
human1 <- subset(human1, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)
human2 <- subset(human2, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)
human3 <- subset(human3, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)

# See number of cells in each sample after quality control
ncol(human1)
ncol(human2)
ncol(human3)
```


# test seurat v5.1

```{r}
# Step 0: Normalise and identify variable features for each dataset
human1 <- human1 %>% NormalizeData() %>% 
          FindVariableFeatures()
human2 <- human2 %>% NormalizeData() %>% 
          FindVariableFeatures()
human3 <- human3 %>% NormalizeData() %>% 
          FindVariableFeatures()

# Step 1: Create a list of Seurat objects
ser_list <- list(human1, human2, human3)

# Step 2: Merge the Seurat objects into one
ser_merged <- merge(
  ser_list[[1]],
  y = c(ser_list[[2]], ser_list[[3]]),
  add.cell.ids = c("human1", "human2", "human3"),
  project = "GSE164528"
)

# Step 3: Perform standard normalization and pre-integration analysis
ser_pre <- ser_merged %>%
  NormalizeData() %>%
  FindVariableFeatures() %>%
  ScaleData(., features = rownames(ser_merged), vars.to.regress = 'percent.mt') %>%
  RunPCA(., features = VariableFeatures(object = ser_merged)) %>%
  FindNeighbors(dims = 1:10) %>%
  FindClusters(resolution = 0.5) %>%
  RunUMAP(dims = 1:10, reduction = "pca")

# Step 4: Perform integration using layers (new method in Seurat v5.1.0)
ser_int <- IntegrateLayers(
  object = ser_pre,
  method = CCAIntegration,
  orig.reduction = "pca",
  new.reduction = "integrated.cca",
  verbose = FALSE
)

# Step 5: Join layers and finalize integration
ser_int[["RNA"]] <- JoinLayers(ser_int[["RNA"]])

ser_int <- ser_int %>%
  FindNeighbors(reduction = "integrated.cca", dims = 1:10) %>%
  FindClusters(resolution = 0.5, cluster.name = "integrated.clusters") %>%
  RunUMAP(dims = 1:10, reduction = "integrated.cca", reduction.name = "integrated.umap")

# Step 6: Save the integrated object for further analysis
saveRDS(ser_int, file = "data/analysis/integrated_sn_human_PVAT_seurat_object.rds")

# Visualisation
print(ser_int[['pca']], dims = 1:5, nfeatures = 5)
VizDimLoadings(ser_int, dims = 1:2, reduction = 'pca')
DimPlot(ser_int, reduction = 'pca')
DimHeatmap(ser_int, dims = 1:15, cells = 500, balanced = TRUE)
ElbowPlot(ser_int)
head(Idents(ser_int), 5)
DimPlot(ser_int, reduction = 'umap')

# Visualise umap coloured on sample origin
ser_int$sample_origin <- sub("_.*", "", colnames(ser_int))
Idents(ser_int) <- "sample_origin"
DimPlot(ser_int, reduction = "umap", group.by = "sample_origin", label = TRUE, repel = TRUE) +
  ggtitle("UMAP Colored by Sample Origin") +
  theme_minimal()
# Visualise PCA coloured by sample origin
DimPlot(ser_int, reduction = "pca", group.by = "sample_origin", label = TRUE)
```

# end of test seurat v5.1

# code for seurat v4

see this vignette: https://satijalab.org/seurat/archive/v4.3/integration_introduction


# end of code for seurat v4




# Normalise the data

We normalise the data using a global-scaling method called "LogNormalize". This process normalises the feature expression levels for each cell by dividing by the total expression, multiplies this by a scale factor (10'000 by default), and applies a log transformation to the result. Normalised values are stored in `human1[["RNA"]]@data`.

```{r}
human1 <- NormalizeData(human1)
human2 <- NormalizeData(human2)
human3 <- NormalizeData(human3)
```

# Find variable features

We identify features that have high cell-to-cell variation, these are likely to have the most biological significance. The function returns 2'000 features per dataset, by default.

```{r}
human1 <- FindVariableFeatures(human1)
human2 <- FindVariableFeatures(human2)
human3 <- FindVariableFeatures(human3)

# Identify the 10 most highly variable genes for the first sample
top10 <- head(VariableFeatures(human1), 10)
top10

# Plot variable features with labels for the first sample
plot1 <- VariableFeaturePlot(human1)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

# Scale the data

We scale the data so that highly expressed genes do not dominate in the downstream analyses. The `ScaleData()` function ensures the mean expression across cells becomes 0, and the variance becomes 1. The results are stored in `human[["RNA"]]$scale.data`.

For clustering, we can scale only variable genes, however the heatmap requires all genes to be scaled. For simplicity we scale all the genes in these datasets.

```{r}
# Scale all genes
human1 <- ScaleData(human1, features = rownames(human1))
human2 <- ScaleData(human2, features = rownames(human2))
human3 <- ScaleData(human3, features = rownames(human3))
```
We also regress out unwanted sources of variation such as mitochondrial reads.

```{r}
human1 <- ScaleData(human1, vars.to.regress = 'percent.mt')
human2 <- ScaleData(human2, vars.to.regress = 'percent.mt')
human3 <- ScaleData(human3, vars.to.regress = 'percent.mt')
```


# Integrate the data - batch correction

Update this (I am not using the v5 workflow): Integration of data from the three different donors is an important step in this snRNA-seq workflow. Seurat v5 allows users to run integration analysis in a single line of code using the `IntegrateLayers` function. This ensures that cells cluster based on biological state and not on sample origin. Details can be found in [this vignette](https://satijalab.org/seurat/articles/seurat5_integration) We specify the desired integration method by adding the parameter `method=HarmonyIntegration`.

```{r}
# Select integration features
features <- SelectIntegrationFeatures(object.list = list(human1, human2, human3))

# Find integration anchors
# This is a time-consuming step, save the object
if (file.exists("data/analysis/anchors.RData")) {
  print("file exists")
  load(file = "data/analysis/anchors.RData")
} else {
  print("file does not exist")
  anchors <- FindIntegrationAnchors(object.list = list(human1, human2, human3), anchor.features = features)
  save(anchors, file = "data/analysis/anchors.RData")
}

# Integrate the datasets
# This is a time-consuming step, save the object
if (file.exists("data/analysis/human_int.RData")) {
  load(file = "data/analysis/human_int.RData")
} else {
  human_int <- IntegrateData(anchorset = anchors)
  save(human_int, file = "data/analysis/human_int.RData")
}
```

This is not working (Seurat v5 workflow).
```{r}
# Add sample information to each Seurat object
#human1$sample <- "human1"
#human2$sample <- "human2"
#human3$sample <- "human3"

# Merge the three Seurat objects
#human_int <- merge(human1, y = c(human2, human3), add.cell.ids = c("human1", "human2", "human3"))

# Split the RNA assay into layers by sample
#human_int[["RNA"]] <- split(human_int[["RNA"]], f = human_int$sample)

# Integrate layers
#human_int <- IntegrateLayers(
#  object = human_int,
#  method = HarmonyIntegration, 
#  orig.reduction = "pca", 
#  new.reduction = "harmony",
#  verbose = FALSE
#)
```


# Linear dimensionality reduction

We now perform PCA on the scaled data with the variable features as input.

## Run PCA on the scaled data

```{r}
human <- RunPCA(human, features = VariableFeatures(object = human))
```

## Visualise PCA results

```{r}

```


*Before differential gene expression, rejoin the layers, but you can always split them again: obj \<- JoinLayers(obj)*
