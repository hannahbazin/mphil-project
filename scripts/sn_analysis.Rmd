---
title: "SnRNA-sequencing analysis of human perivascular adipose tissue (PVAT)"
author: "Hannah Bazin"
date: "r doc_date()"
output: BiocStyle::html_document:
      toc: yes
      toc_depth: 3
      toc_float: yes
      code_folding: "hide" 
---

In this vignette, we are analysing a dataset of single-nucleus RNA sequencing data available on the Gene Expression Omnibus website. There are  single cells that were sequenced on the [Illumina NextSeq 500]. The raw data can be found [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164528).

# Set up

## Load libraries

```{r}
library(GEOquery)
library(Seurat)
library(dplyr)
library(patchwork)
library(ggplot2)
library(ggpubr)
library(tidyverse)
```

## Set working directory

The working directory can be set by running the following command in the terminal: `setwd("/Users/hannahbazin/Desktop/Cambridge/Academics/Han_Lab/MPhil/mphil-project")`

## Load data

The data stems from single-nucleus RNA sequencing experiments of human perivascular adipose tissue from three different healthy donors, sequenced with Illumina NovaSeq 6000. The raw data can be found [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164528). It was first published by Angueira et al. on 12 April 2021 in Nature Metabolism in the paper titled "Defining the lineage of thermogenic perivascular adipose tissue" ([link](https://pubmed.ncbi.nlm.nih.gov/33846639/)).

We read in the data using the `Read10X()` function which takes in three files (barcodes.tsv, genes.tsv, and matrix.mtx) and returns a UMI sparse count matrix representing the gene expression data. This function can be used because the data was generated using CellRanger.

```{r}
human1_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068996_hPVAT1/")
human2_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068997_hPVAT2/")
human3_data <- Read10X(data.dir = "data/GSE164528_RAW/GSM5068998_hPVAT3/")
```

We create Seurat objects from the raw data using `CreateSeuratObject()`. A Seurat object contains both the data (e.g. counts matrix) and the analysis (e.g. clustering results). The parameters `min.cell` and `min.features` allow for initial filtering: we remove genes expressed in less than three cells (sparse expression), as well as cells with fewer than 200 detected genes.

```{r}
human1 <- CreateSeuratObject(counts = human1_data, project = "GSE164528", min.cells = 3, min.features = 200)
human2 <- CreateSeuratObject(counts = human2_data, project = "GSE164528", min.cells = 3, min.features = 200)
human3 <- CreateSeuratObject(counts = human3_data, project = "GSE164528", min.cells = 3, min.features = 200)

# See number of cells in each sample
ncol(human1)
ncol(human2)
ncol(human3)
```

# Pre-processing workflow

## Visualise QC metrics and select cells

### Add mitochondrial reads

We add the percentage of mitochondrial genes to the metadata for all three samples. This is an important Quality Control metric. In single nucleus RNA sequencing data, as opposed to those from single cell RNA sequencing, we expect very low mitochondrial gene expression. We need to filter out the samples with high mitochondrial gene expression, because this might indicate that the mitochondria attached to the nucleus during isolation.

```{r}
human1[["percent.mt"]] <- PercentageFeatureSet(human1, pattern = "^MT-")
human2[["percent.mt"]] <- PercentageFeatureSet(human2, pattern = "^MT-")
human3[["percent.mt"]] <- PercentageFeatureSet(human3, pattern = "^MT-")
```

### Determine cut-off

We visualise Quality Control metrics for each of the samples and determine the cut-off for filtering the cells based on these plots.

```{r}
# Show QC metrics for the first 5 cells of each sample
head(human1@meta.data, 5)
head(human2@meta.data, 5)
head(human3@meta.data, 5)
```

```{r fig.height=7, fig.width=13}
VlnPlot(human1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(human2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(human3, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

```{r fig.height=7, fig.width=11}
plot1 <- FeatureScatter(human1, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(human2, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(human3, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(human3, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

### Filter cells

From the violin plots, we identify the filtering thresholds and select cells as follows: - We filter cells that have unique feature counts over 6'000 or below 1'000. - We filter cells that have RNA counts over 40'000 and below 500. - We filter cells that have \>1% mitochondrial counts. We use the same cut-off values in all three samples for consistency.

```{r}
human1 <- subset(human1, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)
human2 <- subset(human2, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)
human3 <- subset(human3, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000 & nCount_RNA > 500 & nCount_RNA < 40000 & percent.mt < 1)

# See number of cells in each sample after quality control
ncol(human1)
ncol(human2)
ncol(human3)
```

# Normalise the data

We normalise the data using a global-scaling method called "LogNormalize". This process normalises the feature expression levels for each cell by dividing by the total expression, multiplies this by a scale factor (10'000 by default), and applies a log transformation to the result. Normalised values are stored in `pbmc[["RNA"]]@data`.

```{r}
human1 <- NormalizeData(human1, normalization.method = "LogNormalize", scale.factor = 10000)
human2 <- NormalizeData(human2, normalization.method = "LogNormalize", scale.factor = 10000)
human3 <- NormalizeData(human3, normalization.method = "LogNormalize", scale.factor = 10000)
```

# Integrate the data - batch correction

Integration of data from the three different donors is an important step in the snRNA-seq workflow. Seurat v5 allows users to run integration analysis in a single line of code using the `IntegrateLayers` function. This ensures that cells cluster based on biological state and not sample origin. Details can be found in [this vignette](https://satijalab.org/seurat/articles/seurat5_integration) We specify the desired integration method by adding the parameter `method=HarmonyIntegration`.

*Before differential gene expression, rejoin the layers, but you can always split them again: obj \<- JoinLayers(obj)*

# TODO: REPLACE MERGE WITH INTEGRATE

We can merge the three Seurat objects into one, as they all come from healthy human tissues.

```{r}
human_merged <- merge(human1, y = c(human2, human3), add.cell.ids = c("human1", "human2", "human3"), project = "GSE164528")

# Show object
human_merged

# Verify the column names
head(colnames(human_merged))
tail(colnames(human_merged))
```

Since we have single-nucleus data, and not single-cell, we expect no mitochondrial gene expression in the samples. If there is, this indicates that mitochondria may have attached to the nucleus during isolation, a sign of bad quality. Therefore, we use the presence of mitochondrial genes as quality control.

-   `nFeature_RNA`: number of non-zero expressed genes in one cell, thus indicates the diversity of gene expression within a cell. A low number may indicate a low-quality cell or an empty droplet. An aberrantly high number may indicate a cell doublet or multiplet.
-   `percent.mt`: percentage of mitochondrial genes in one cell. A high number may indicate a low-quality sample where the mitochondria attached to the nucleus during isolation.

The `[[` operator can add columns to object metadata. First, we store the mitochondrial QC stat here. The `^` character ensures it matches only the start of a string.

```{r}

# Show QC metrics for the first 5 cells
head(human_merged@meta.data, 5)
```


# Feature selection

We identify features that have high cell-to-cell variation, these are likely to have the most biological significance. The function returns 2'000 features per dataset, by default.

```{r}
human <- FindVariableFeatures(human, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(human), 10)
top10

# Plot variable features with labels
plot1 <- VariableFeaturePlot(human)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

# Scale the data

We scale the data so that highly expressed genes do not dominate in the downstream analyses. The `ScaleData()` function ensures the mean expression across cells becomes 0, and the variance becomes 1. The results are stored in `human[["RNA"]]$scale.data`.

For clustering, we can scale only variable genes, however the heatmap requires all genes to be scaled.

```{r}
all_genes <- rownames(human)
human <- ScaleData(human, features = all_genes)
```

# Linear dimensionality reduction

We now perform PCA on the scaled data with the variable features as input.

## Run PCA on the scaled data

```{r}
human <- RunPCA(human, features = VariableFeatures(object = human))
```

## Visualise PCA results

```{r}

```
